const ANIMALS = ['Penguin', 'Alpaca', 'Sloth', 'Owl', 'Sea Otter'];
const scriptProperties = PropertiesService.getScriptProperties();

// --- 重置函式 ---
function resetAllData() {
  scriptProperties.deleteProperty('PAIRING_DATA');
  scriptProperties.deleteProperty('ROLE_MAP');
  
  // 1. 洗牌並存入牌堆
  const shuffled = [...ANIMALS].sort(() => 0.5 - Math.random());
  scriptProperties.setProperty('AVAILABLE_ROLES', JSON.stringify(shuffled));
  
  // 2. 清除試算表
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName('Data');
  if (sheet) {
    sheet.clear();
    sheet.appendRow(['Nickname', 'Feature1', 'Feature2', 'Timestamp', 'RealName']); 
  }
  console.log("遊戲已重置！");
}

function doGet(e) {
  const uuid = e.parameter.uuid;
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName('Data');
  const rows = sheet.getDataRange().getValues();
  rows.shift(); 
  
  const submissions = {};
  const profiles = {}; 
  let validCount = 0;

  rows.forEach(row => {
    // 判斷是否有效許願 (有特徵)
    if(row[0] && row[1] && row[2]) {
      submissions[row[0]] = [row[1], row[2]];
      validCount++;
    }
    // 判斷是否有填寫姓名
    if(row[0] && row[4]) {
      profiles[row[0]] = { name: row[4] };
    }
  });

  let roleMapJson = scriptProperties.getProperty('ROLE_MAP');
  let roleMap = roleMapJson ? JSON.parse(roleMapJson) : {};

  let pairingJson = scriptProperties.getProperty('PAIRING_DATA');
  let pairings = pairingJson ? JSON.parse(pairingJson) : null;
  if (validCount < 5) pairings = null;

  let myAssignedRole = null;
  if (uuid && roleMap[uuid]) {
    myAssignedRole = roleMap[uuid];
  }

  const responseData = {
    myRole: myAssignedRole,        
    submissions: submissions,
    profiles: profiles,
    pairings: pairings,
    submissionCount: validCount,
    isPaired: !!pairings,      
    canPair: validCount >= 5   
  };

  return ContentService.createTextOutput(JSON.stringify(responseData))
    .setMimeType(ContentService.MimeType.JSON);
}

function doPost(e) {
  const lock = LockService.getScriptLock();
  lock.tryLock(10000);
  
  try {
    const params = JSON.parse(e.postData.contents);
    const action = params.action; 
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName('Data');

    // --- 動作 0: 抽取角色 (加入自動回收邏輯) ---
    if (action === 'draw_role') {
      const uuid = params.uuid;
      
      let roleMapJson = scriptProperties.getProperty('ROLE_MAP');
      let roleMap = roleMapJson ? JSON.parse(roleMapJson) : {};

      // 1. 如果此 UUID 已經有角色，直接回傳
      if (roleMap[uuid]) {
         return ContentService.createTextOutput(JSON.stringify({ status: 'success', role: roleMap[uuid] }));
      }

      // 2. 讀取牌堆
      let availableJson = scriptProperties.getProperty('AVAILABLE_ROLES');
      let availableRoles = availableJson ? JSON.parse(availableJson) : [];

      // 3. 【關鍵修正】如果牌堆空了，檢查是否有「幽靈人口」(領了牌但沒填資料)
      if (!availableRoles || availableRoles.length === 0) {
          // 讀取目前 Excel 裡已經「正式註冊」的動物
          const data = sheet.getDataRange().getValues();
          const registeredAnimals = [];
          // 從第2列開始讀 (跳過標題)
          for (let i = 1; i < data.length; i++) {
            if (data[i][0]) registeredAnimals.push(data[i][0]);
          }

          // 找出哪些動物還沒在 Excel 裡
          const missingAnimals = ANIMALS.filter(a => !registeredAnimals.includes(a));

          if (missingAnimals.length > 0) {
             // 發現有動物被浪費了！回收第一隻給現在這個人
             // (這裡我們隨機選一隻或拿第一隻都可以)
             const recycledRole = missingAnimals[0];
             
             // 強制指派給新使用者
             roleMap[uuid] = recycledRole;
             scriptProperties.setProperty('ROLE_MAP', JSON.stringify(roleMap));
             
             return ContentService.createTextOutput(JSON.stringify({ status: 'success', role: recycledRole }));
          } else {
             // 真的滿了 (Excel 裡有 5 筆資料)
             return ContentService.createTextOutput(JSON.stringify({ status: 'error', message: '角色已全數抽完且額滿！' }));
          }
      }

      // 4. 正常抽牌流程 (牌堆還有牌)
      const newRole = availableRoles.pop();
      roleMap[uuid] = newRole;

      scriptProperties.setProperty('AVAILABLE_ROLES', JSON.stringify(availableRoles));
      scriptProperties.setProperty('ROLE_MAP', JSON.stringify(roleMap));

      return ContentService.createTextOutput(JSON.stringify({ status: 'success', role: newRole }));
    }

    // --- 其他動作 ---
    const nickname = params.nickname;
    
    const data = sheet.getDataRange().getValues();
    let rowIndex = -1;
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] === nickname) {
        rowIndex = i + 1;
        break;
      }
    }
    // 若無此動物資料列，則新增
    if (rowIndex === -1 && nickname) {
      sheet.appendRow([nickname, '', '', new Date(), '']);
      rowIndex = sheet.getLastRow();
    }

    if (action === 'submit_feature') {
      sheet.getRange(rowIndex, 2).setValue(params.feature1);
      sheet.getRange(rowIndex, 3).setValue(params.feature2);
      sheet.getRange(rowIndex, 4).setValue(new Date());
      return ContentService.createTextOutput(JSON.stringify({ status: 'success' }));
    }
    
    else if (action === 'submit_profile') {
      sheet.getRange(rowIndex, 5).setValue(params.realName);
      return ContentService.createTextOutput(JSON.stringify({ status: 'success' }));
    }
    
    else if (action === 'generate_pair') {
      let currentPairing = scriptProperties.getProperty('PAIRING_DATA');
      if (currentPairing) {
         return ContentService.createTextOutput(JSON.stringify({ status: 'success', message: 'Already paired' }));
      }
      
      // 嚴格檢查 Excel 裡是否有 5 筆完整資料
      const rows = sheet.getDataRange().getValues();
      rows.shift();
      const realCount = rows.filter(r => r[0] && r[1] && r[2]).length;
      
      if (realCount < 5) {
        return ContentService.createTextOutput(JSON.stringify({ status: 'error', message: '人數不足 5 人，請確認大家是否都已送出願望' }));
      }
 
      const shuffled = [...ANIMALS].sort(() => 0.5 - Math.random());
      const pairing = [];
      for (let i = 0; i < shuffled.length; i++) {
        pairing.push({ from: shuffled[i], to: shuffled[(i + 1) % shuffled.length] });
      }
      scriptProperties.setProperty('PAIRING_DATA', JSON.stringify(pairing));
      return ContentService.createTextOutput(JSON.stringify({ status: 'success', data: pairing }));
    }
 
  } catch (err) {
    return ContentService.createTextOutput(JSON.stringify({ status: 'error', message: err.toString() }));
  } finally {
    lock.releaseLock();
  }
}
